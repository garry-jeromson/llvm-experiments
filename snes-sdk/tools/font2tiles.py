#!/usr/bin/env python3
"""
font2tiles.py - Convert font images to SNES tile data

Takes a grid of character glyphs and outputs tile data for ASCII characters 32-126.

Usage:
    python font2tiles.py charset.png -o font.s [options]

Options:
    -o, --output      Output file (default: stdout)
    --grid            Grid size (e.g., 8x8, 16x16) - default: 8x8
    --cols            Characters per row (auto-detect if not specified)
    --start-char      ASCII code of first character (default: 32 = space)
    --mode            Bits per pixel: 2 or 4 (default: 2)
    --label           Label prefix (default: font)
    --raw             Output raw binary instead of assembly
"""

import argparse
import sys
from pathlib import Path
from typing import List, Tuple

try:
    from PIL import Image
    HAS_PIL = True
except ImportError:
    HAS_PIL = False
    Image = None  # type: ignore


def rgb_to_bgr555(r: int, g: int, b: int) -> int:
    """Convert 8-bit RGB to BGR555 format."""
    r5 = r >> 3
    g5 = g >> 3
    b5 = b >> 3
    return (b5 << 10) | (g5 << 5) | r5


def get_pixel_value(img: Image.Image, x: int, y: int) -> int:
    """Get pixel value (0 = background, 1+ = foreground)."""
    if img.mode == 'P':
        return img.getpixel((x, y))
    elif img.mode == 'L':
        # Grayscale - threshold at 128
        return 1 if img.getpixel((x, y)) >= 128 else 0
    elif img.mode == '1':
        return 1 if img.getpixel((x, y)) else 0
    else:
        # RGB - use luminance
        r, g, b = img.convert('RGB').getpixel((x, y))[:3]
        lum = (r * 299 + g * 587 + b * 114) // 1000
        return 1 if lum >= 128 else 0


def extract_char_2bpp(img: Image.Image, cx: int, cy: int, glyph_w: int, glyph_h: int) -> bytes:
    """Extract a single character glyph in 2bpp format."""
    data = []

    # For fonts, we only use 8x8 tiles
    # If glyph is larger, we'd need to extract multiple tiles
    for row in range(min(glyph_h, 8)):
        byte0 = 0
        byte1 = 0

        for col in range(min(glyph_w, 8)):
            px = get_pixel_value(img, cx * glyph_w + col, cy * glyph_h + row)

            if px & 0x01:
                byte0 |= (0x80 >> col)
            if px & 0x02:
                byte1 |= (0x80 >> col)

        data.append(byte0)
        data.append(byte1)

    # Pad to 8 rows if glyph is shorter
    while len(data) < 16:
        data.append(0)
        data.append(0)

    return bytes(data)


def extract_char_4bpp(img: Image.Image, cx: int, cy: int, glyph_w: int, glyph_h: int) -> bytes:
    """Extract a single character glyph in 4bpp format."""
    data = []

    # Bitplanes 0-1
    for row in range(min(glyph_h, 8)):
        byte0 = 0
        byte1 = 0

        for col in range(min(glyph_w, 8)):
            px = get_pixel_value(img, cx * glyph_w + col, cy * glyph_h + row)

            if px & 0x01:
                byte0 |= (0x80 >> col)
            if px & 0x02:
                byte1 |= (0x80 >> col)

        data.append(byte0)
        data.append(byte1)

    while len(data) < 16:
        data.append(0)
        data.append(0)

    # Bitplanes 2-3
    for row in range(min(glyph_h, 8)):
        byte2 = 0
        byte3 = 0

        for col in range(min(glyph_w, 8)):
            px = get_pixel_value(img, cx * glyph_w + col, cy * glyph_h + row)

            if px & 0x04:
                byte2 |= (0x80 >> col)
            if px & 0x08:
                byte3 |= (0x80 >> col)

        data.append(byte2)
        data.append(byte3)

    while len(data) < 32:
        data.append(0)
        data.append(0)

    return bytes(data)


def convert_font(img: Image.Image, glyph_w: int, glyph_h: int, cols: int,
                 start_char: int, bpp: int) -> Tuple[List[bytes], int]:
    """
    Convert font image to tile data.

    Returns (tiles, num_chars)
    """
    width, height = img.size

    if cols == 0:
        cols = width // glyph_w

    rows = height // glyph_h
    total_chars = cols * rows

    # Number of printable ASCII characters (space through ~)
    num_printable = 95  # 32 to 126 inclusive

    extract_fn = extract_char_2bpp if bpp == 2 else extract_char_4bpp

    tiles = []

    for i in range(min(total_chars, num_printable)):
        cx = i % cols
        cy = i // cols
        tile = extract_fn(img, cx, cy, glyph_w, glyph_h)
        tiles.append(tile)

    # Pad with blank tiles if image doesn't have all characters
    blank = bytes(16 if bpp == 2 else 32)
    while len(tiles) < num_printable:
        tiles.append(blank)

    return tiles, len(tiles)


def format_assembly(tiles: List[bytes], label: str, bpp: int, start_char: int) -> str:
    """Format font data as ca65 assembly."""
    bytes_per_tile = 16 if bpp == 2 else 32

    lines = [
        f"; Generated by font2tiles.py",
        f"; {len(tiles)} character tiles ({bpp}bpp, {bytes_per_tile} bytes each)",
        f"; ASCII {start_char} ('{chr(start_char)}') to {start_char + len(tiles) - 1} ('{chr(min(126, start_char + len(tiles) - 1))}')",
        "",
        ".segment \"RODATA\"",
        "",
        f".global {label}_tiles",
        f"{label}_tiles:",
    ]

    for i, tile in enumerate(tiles):
        char_code = start_char + i
        char_repr = chr(char_code) if 32 <= char_code < 127 else '?'
        lines.append(f"    ; Char {char_code} '{char_repr}'")

        for j in range(0, len(tile), 8):
            chunk = tile[j:j+8]
            hex_str = ", ".join(f"${b:02X}" for b in chunk)
            lines.append(f"    .byte {hex_str}")

    lines.extend([
        f"{label}_tiles_end:",
        f".global {label}_tiles_size",
        f"{label}_tiles_size = {label}_tiles_end - {label}_tiles",
        "",
        f".global {label}_num_chars",
        f"{label}_num_chars = {len(tiles)}",
        f".global {label}_start_char",
        f"{label}_start_char = {start_char}",
        f".global {label}_bpp",
        f"{label}_bpp = {bpp}",
        "",
    ])

    return "\n".join(lines)


def main():
    if not HAS_PIL:
        print("Error: PIL/Pillow is required. Install with: pip install Pillow", file=sys.stderr)
        sys.exit(1)

    parser = argparse.ArgumentParser(description="Convert font image to SNES tiles")
    parser.add_argument("input", help="Input PNG file (grid of characters)")
    parser.add_argument("-o", "--output", help="Output file (default: stdout)")
    parser.add_argument("--grid", default="8x8",
                        help="Glyph size (e.g., 8x8, 16x16)")
    parser.add_argument("--cols", type=int, default=0,
                        help="Characters per row (auto-detect if 0)")
    parser.add_argument("--start-char", type=int, default=32,
                        help="ASCII code of first character (default: 32)")
    parser.add_argument("--mode", type=int, choices=[2, 4], default=2,
                        help="Bits per pixel (default: 2)")
    parser.add_argument("--label", default="font",
                        help="Label prefix (default: font)")
    parser.add_argument("--raw", action="store_true",
                        help="Output raw binary instead of assembly")

    args = parser.parse_args()

    # Parse grid size
    try:
        glyph_w, glyph_h = map(int, args.grid.lower().split('x'))
    except ValueError:
        print(f"Error: Invalid grid size '{args.grid}'", file=sys.stderr)
        sys.exit(1)

    # Load image
    try:
        img = Image.open(args.input)
    except Exception as e:
        print(f"Error loading image: {e}", file=sys.stderr)
        sys.exit(1)

    print(f"Input: {img.size[0]}x{img.size[1]}, glyph size {glyph_w}x{glyph_h}", file=sys.stderr)

    # Convert
    tiles, num_chars = convert_font(img, glyph_w, glyph_h, args.cols,
                                     args.start_char, args.mode)

    print(f"Output: {num_chars} characters, {args.mode}bpp", file=sys.stderr)

    if args.raw:
        # Output raw binary
        output = b''.join(tiles)
        if args.output:
            with open(args.output, 'wb') as f:
                f.write(output)
        else:
            sys.stdout.buffer.write(output)
    else:
        # Output assembly
        output = format_assembly(tiles, args.label, args.mode, args.start_char)

        if args.output:
            with open(args.output, 'w') as f:
                f.write(output)
        else:
            print(output)


if __name__ == "__main__":
    main()
