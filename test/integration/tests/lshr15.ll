; INTEGRATION-TEST
; EXPECT: 3

; Test lshr by 15 (sign bit extraction) optimization
; This pattern is generated by LLVM when optimizing signed comparisons with 0

target triple = "w65816-unknown-none"

define i16 @test_main() {
  ; Test 1: Positive number (bit 15 = 0)
  %pos = add i16 0, 100
  %pos_sign = lshr i16 %pos, 15
  ; %pos_sign should be 0

  ; Test 2: Negative number (bit 15 = 1)
  %neg = sub i16 0, 100       ; -100 = 0xFF9C
  %neg_sign = lshr i16 %neg, 15
  ; %neg_sign should be 1

  ; Test 3: Zero (bit 15 = 0)
  %zero_sign = lshr i16 0, 15
  ; %zero_sign should be 0

  ; Test 4: Maximum positive (0x7FFF, bit 15 = 0)
  %maxpos = add i16 0, 32767
  %maxpos_sign = lshr i16 %maxpos, 15
  ; %maxpos_sign should be 0

  ; Test 5: Minimum negative (0x8000, bit 15 = 1)
  %minneg = add i16 0, 32768  ; -32768 in signed
  %minneg_sign = lshr i16 %minneg, 15
  ; %minneg_sign should be 1

  ; Test 6: -1 (0xFFFF, bit 15 = 1)
  %minus1 = sub i16 0, 1
  %minus1_sign = lshr i16 %minus1, 15
  ; %minus1_sign should be 1

  ; Sum up all sign bits: 0 + 1 + 0 + 0 + 1 + 1 = 3
  %sum1 = add i16 %pos_sign, %neg_sign
  %sum2 = add i16 %sum1, %zero_sign
  %sum3 = add i16 %sum2, %maxpos_sign
  %sum4 = add i16 %sum3, %minneg_sign
  %sum5 = add i16 %sum4, %minus1_sign

  ret i16 %sum5
}
